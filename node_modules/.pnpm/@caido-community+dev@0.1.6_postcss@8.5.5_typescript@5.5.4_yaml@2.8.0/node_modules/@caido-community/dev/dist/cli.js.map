{"version":3,"sources":["../src/cli.ts","../src/build/frontend.ts","../src/utils/cp.ts","../src/utils/log.ts","../src/utils/slash.ts","../src/utils/zip.ts","../src/build/backend.ts","../src/bundle/index.ts","../src/manifest.ts","../src/bundle/backend.ts","../src/bundle/frontend.ts","../src/config.ts","../src/types.ts","../src/commands/build.ts","../src/commands/watch.ts"],"sourcesContent":["#!/usr/bin/env node\nimport chalk from \"chalk\";\nimport { Command } from \"commander\";\n\nimport { build, watch } from \"./commands\";\n\nconst program = new Command();\n\n/**\n * Creates a runner function for a command, that handles errors and exits the process with a non-zero exit code.\n * @param fn - The function to run.\n * @returns The runner function.\n */\nfunction runner<T>(fn: (...args: T[]) => Promise<void>) {\n  return async (...args: T[]) => {\n    try {\n      await fn(...args);\n    } catch (error) {\n      const buildError =\n        error instanceof Error ? error : new Error(\"Unknown error occurred\");\n      console.error(chalk.red(`\\n${buildError.message}`));\n      console.error(chalk.red(`${buildError.stack}`));\n      process.exit(1);\n    }\n  };\n}\n\nprogram\n  .name(\"caido-dev\")\n  .description(\"Development tools for building Caido plugins\")\n  .version(\"1.0.0\");\n\nprogram\n  .command(\"build [path]\")\n  .description(\"Build the Caido plugin\")\n  .option(\"-c, --config <path>\", \"Path to caido.config.ts file\")\n  .action(\n    runner((path, args) =>\n      build({\n        path,\n        ...args,\n      }),\n    ),\n  );\n\nprogram\n  .command(\"watch [path]\")\n  .description(\"Start development server and watch for changes\")\n  .option(\"-c, --config <path>\", \"Path to caido.config.ts file\")\n  .action(\n    runner((path, args) =>\n      watch({\n        path,\n        ...args,\n      }),\n    ),\n  );\n\nprogram\n  .command(\"dev\")\n  .description(\"Start development server\")\n  .option(\"-c, --config <path>\", \"Path to caido.config.ts file\")\n  .action(() => {});\n\ntry {\n  program.parse();\n} catch (error) {\n  const buildError =\n    error instanceof Error ? error : new Error(\"Unknown error occurred\");\n  console.error(chalk.red(`\\n${buildError.message}`));\n  process.exit(1);\n}\n","import { existsSync } from \"fs\";\nimport path from \"path\";\n\nimport { build, defineConfig, mergeConfig } from \"vite\";\n\nimport type { FrontendBuildOutput, FrontendPluginConfig } from \"../types\";\nimport { logInfo } from \"../utils\";\n\n/**\n * Creates a Vite config for the frontend plugin.\n * @param cwd - The current working directory.\n * @param plugin - The frontend plugin configuration.\n * @returns The Vite config.\n */\nfunction createViteConfig(cwd: string, plugin: FrontendPluginConfig) {\n  // Set the entry point\n  const root = path.resolve(cwd, plugin.root);\n  const baseConfig = defineConfig({\n    root,\n    build: {\n      outDir: \"dist\",\n      emptyOutDir: true,\n      lib: {\n        entry: \"src/index.ts\",\n        formats: [\"es\"],\n        fileName: () => \"index.js\",\n        cssFileName: \"index\",\n      },\n    },\n    define: { \"process.env.NODE_ENV\": '\"production\"' },\n  });\n\n  return mergeConfig(baseConfig, plugin.vite ?? {});\n}\n\n/**\n * Builds the frontend plugin.\n * @param cwd - The current working directory.\n * @param pluginConfig - The frontend plugin configuration.\n * @returns The build output.\n */\nexport async function buildFrontendPlugin(\n  cwd: string,\n  pluginConfig: FrontendPluginConfig,\n): Promise<FrontendBuildOutput> {\n  const pluginRoot = path.resolve(cwd, pluginConfig.root);\n\n  logInfo(`Building frontend plugin: ${pluginRoot}`);\n  const viteConfig = createViteConfig(cwd, pluginConfig);\n  await build(viteConfig);\n\n  const hasCss = existsSync(`${pluginRoot}/dist/index.css`);\n  logInfo(\"Frontend plugin built successfully\");\n\n  return {\n    kind: \"frontend\",\n    id: pluginConfig.id,\n    name: pluginConfig.name ?? \"frontend\",\n    fileName: path.join(pluginRoot, \"dist\", \"index.js\"),\n    cssFileName: hasCss\n      ? path.join(pluginRoot, \"dist\", \"index.css\")\n      : undefined,\n    backendId: pluginConfig.backend?.id,\n    assets: pluginConfig.assets ?? [],\n  };\n}\n","import fs from \"fs\";\nimport path from \"path\";\n\nimport { Glob } from \"glob\";\n\n/**\n * Copies a file or directory from the source to the destination.\n * Supports glob patterns.\n * @param cwd - The current working directory.\n * @param src - The source glob pattern.\n * @param dest - The destination directory.\n */\nexport function cp(cwd: string, src: string, dest: string) {\n  const glob = new Glob(src, { cwd });\n\n  for (const file of glob) {\n    const fileSrc = path.join(cwd, file);\n\n    // If the source is a file, we need to copy it to the destination.\n    // Otherwise, we need to copy the entire directory content.\n    let fileDest = dest;\n    if (fs.statSync(fileSrc).isFile()) {\n      const fileName = path.basename(file);\n      fileDest = path.join(dest, fileName);\n    }\n    // eslint-disable-next-line n/no-unsupported-features/node-builtins\n    fs.cpSync(fileSrc, fileDest, { recursive: true });\n  }\n}\n","import chalk from \"chalk\";\n\nexport function logSuccess(message: string) {\n  console.log(chalk.green(\"[*]\"), message);\n}\n\nexport function logInfo(message: string) {\n  console.log(chalk.blue(\"[*]\"), message);\n}\n\nexport function logError(message: string) {\n  console.error(chalk.red(\"[!]\"), message);\n}\n","export function slash(path: string): string {\n  return path.replace(/\\\\/g, \"/\");\n}\n","import { readdir, readFile, stat } from \"fs/promises\";\nimport { join } from \"path\";\n\nimport type JSZip from \"jszip\";\n\nimport { slash } from \"./slash\";\n\n/**\n * Recursively adds files from a directory to a JSZip object\n * @param zip The JSZip object to add files to\n * @param dirPath The path to the directory to add\n * @param parentPath Optional parent path for nested directories\n */\nexport async function addDirectoryToZip(\n  zip: JSZip,\n  dirPath: string,\n  parentPath: string = \"\",\n) {\n  const entries = await readdir(dirPath);\n\n  for (const entry of entries) {\n    const fullPath = join(dirPath, entry);\n    const stats = await stat(fullPath);\n    const relativePath = parentPath ? join(parentPath, entry) : entry;\n\n    if (stats.isDirectory()) {\n      await addDirectoryToZip(zip, fullPath, relativePath);\n    } else {\n      const content = await readFile(fullPath);\n      zip.file(slash(relativePath), content);\n    }\n  }\n}\n","import { builtinModules } from \"module\";\nimport path from \"path\";\n\nimport { build, defineConfig, type Options } from \"tsup\";\n\nimport type { BackendBuildOutput, BackendPluginConfig } from \"../types\";\nimport { logInfo, slash } from \"../utils\";\n\n/**\n * Creates a tsup config for the backend plugin.\n * @param cwd - The current working directory.\n * @param plugin - The backend plugin configuration.\n * @returns The tsup config.\n */\nfunction createTsupConfig(cwd: string, plugin: BackendPluginConfig) {\n  const root = path.resolve(cwd, plugin.root);\n  return defineConfig({\n    target: \"esnext\",\n    entry: [slash(path.resolve(root, \"src/index.ts\"))],\n    outDir: slash(path.resolve(root, \"dist\")),\n    outExtension: (ctx) => {\n      return { js: \".js\" };\n    },\n    format: [\"esm\"],\n    config: false,\n    clean: true,\n    sourcemap: false,\n    external: [/caido:.+/, \"sqlite\", ...builtinModules],\n  }) as Options;\n}\n\n/**\n * Builds the backend plugin.\n * @param cwd - The current working directory.\n * @param pluginConfig - The backend plugin configuration.\n * @returns The build output.\n */\nexport async function buildBackendPlugin(\n  cwd: string,\n  pluginConfig: BackendPluginConfig,\n): Promise<BackendBuildOutput> {\n  const pluginRoot = path.resolve(cwd, pluginConfig.root);\n\n  logInfo(`Building backend plugin: ${pluginRoot}`);\n  const tsupConfig = createTsupConfig(cwd, pluginConfig);\n  await build(tsupConfig);\n  logInfo(\"Backend built successfully\");\n\n  return {\n    kind: \"backend\",\n    id: pluginConfig.id,\n    name: pluginConfig.name ?? \"backend\",\n    fileName: path.join(pluginRoot, \"dist\", \"index.js\"),\n    assets: pluginConfig.assets ?? [],\n  };\n}\n","import fs from \"fs/promises\";\nimport path from \"path\";\n\nimport { validateManifest } from \"@caido/plugin-manifest\";\nimport JSZip from \"jszip\";\n\nimport { createManifest } from \"../manifest\";\nimport type { BuildOutput, CaidoConfig } from \"../types\";\nimport { addDirectoryToZip, logInfo, logSuccess } from \"../utils\";\n\nimport { bundleBackendPlugin } from \"./backend\";\nimport { bundleFrontendPlugin } from \"./frontend\";\n\n/**\n * Creates the dist directories.\n * @param cwd - The current working directory.\n * @returns The dist directory and the plugin package directory.\n */\nasync function createDistDirectories(cwd: string) {\n  const distDir = path.resolve(cwd, \"dist\");\n  await fs.rm(distDir, {\n    recursive: true,\n    force: true,\n  });\n\n  const pluginPackageDir = path.join(distDir, \"plugin_package\");\n  await fs.mkdir(pluginPackageDir, { recursive: true });\n\n  return {\n    distDir,\n    pluginPackageDir,\n  };\n}\n\n/**\n * Bundles the plugin package.\n * @param options - The options.\n * @param options.cwd - The current working directory.\n * @param options.packageJson - The root package.json.\n * @param options.buildOutputs - The build outputs.\n * @returns The plugin package.\n */\nexport async function bundlePackage(options: {\n  cwd: string;\n  buildOutputs: BuildOutput[];\n  config: CaidoConfig;\n}): Promise<void> {\n  logInfo(\"Bundling plugin package\");\n  const { cwd, buildOutputs, config } = options;\n\n  // Create dist directories\n  const { distDir, pluginPackageDir } = await createDistDirectories(cwd);\n\n  // Create manifest\n  const manifest = createManifest({ config });\n\n  // Copy build outputs to dist directory\n  for (const buildOutput of buildOutputs) {\n    switch (buildOutput.kind) {\n      case \"frontend\":\n        manifest.plugins.push(\n          bundleFrontendPlugin(cwd, pluginPackageDir, buildOutput),\n        );\n        break;\n      case \"backend\":\n        manifest.plugins.push(\n          bundleBackendPlugin(cwd, pluginPackageDir, buildOutput),\n        );\n        break;\n    }\n  }\n\n  // Assert that the manifest is valid\n  if (!validateManifest(manifest)) {\n    throw new Error(\n      \"Manifest is not valid:\" + JSON.stringify(manifest, null, 2),\n    );\n  }\n\n  // Write manifest to dist directory\n  const manifestPath = path.join(pluginPackageDir, \"manifest.json\");\n  const manifestContent = JSON.stringify(manifest, null, 2);\n  await fs.writeFile(manifestPath, manifestContent);\n\n  // Generate zip file\n  const zip = new JSZip();\n\n  // Zip all the contents of the plugin package directory\n  await addDirectoryToZip(zip, pluginPackageDir);\n\n  // Write zip file to dist directory\n  const zipPath = path.join(distDir, \"plugin_package.zip\");\n  const zipFile = await fs.open(zipPath, \"w\");\n  await new Promise<void>((resolve, reject) => {\n    zip\n      .generateNodeStream({\n        type: \"nodebuffer\",\n        streamFiles: true,\n      })\n      .pipe(zipFile.createWriteStream())\n      .on(\"finish\", () => {\n        logSuccess(\"Plugin package zip file created successfully\");\n        resolve();\n      })\n      .on(\"error\", reject);\n  });\n}\n","import type { Manifest, ManifestPlugin } from \"@caido/plugin-manifest\";\n\nimport { type CaidoConfig } from \"./types\";\n\nexport function createManifest(options: { config: CaidoConfig }): Manifest {\n  const { config } = options;\n  return {\n    id: config.id,\n    name: config.name,\n    version: config.version,\n    description: config.description,\n    author: {\n      name: config.author.name,\n      email: config.author?.email,\n      url: config.author?.url,\n    },\n    links: {\n      sponsor: config.links?.sponsor,\n    },\n    plugins: [],\n  };\n}\n\nexport function defineFrontendPluginManifest(\n  pluginManifest: Extract<ManifestPlugin, { kind: \"frontend\" }>,\n) {\n  return pluginManifest;\n}\n\nexport function defineBackendPluginManifest(\n  pluginManifest: Extract<ManifestPlugin, { kind: \"backend\" }>,\n) {\n  return pluginManifest;\n}\n","import fs from \"fs\";\nimport path from \"path\";\n\nimport { defineBackendPluginManifest } from \"../manifest\";\nimport { type BackendBuildOutput } from \"../types\";\nimport { cp, slash } from \"../utils\";\n\n/**\n * Bundles the backend plugin\n * @param pluginPackageDir - The directory to bundle the plugin into.\n * @param buildOutput - The build output.\n */\nexport function bundleBackendPlugin(\n  cwd: string,\n  pluginPackageDir: string,\n  buildOutput: BackendBuildOutput,\n) {\n  // Create plugin directory\n  const pluginDir = path.join(pluginPackageDir, buildOutput.id);\n  fs.mkdirSync(pluginDir, { recursive: true });\n\n  // Copy JS file\n  const jsDestPath = path.join(pluginDir, path.basename(buildOutput.fileName));\n  fs.copyFileSync(buildOutput.fileName, jsDestPath);\n  const jsRelativePath = slash(path.relative(pluginPackageDir, jsDestPath));\n\n  // Copy assets if required\n  let assetsRelativePath: string | undefined;\n  if (buildOutput.assets.length > 0) {\n    // Create assets directory\n    const assetsDir = path.join(pluginDir, \"assets\");\n    fs.mkdirSync(assetsDir, { recursive: true });\n\n    // Copy assets\n    for (const asset of buildOutput.assets) {\n      cp(cwd, asset, assetsDir);\n    }\n\n    assetsRelativePath = slash(path.relative(pluginPackageDir, assetsDir));\n  }\n\n  return defineBackendPluginManifest({\n    id: buildOutput.id,\n    kind: \"backend\",\n    name: buildOutput.name ?? buildOutput.id,\n    entrypoint: jsRelativePath,\n    runtime: \"javascript\",\n    assets: assetsRelativePath,\n  });\n}\n","import fs from \"fs\";\nimport path from \"path\";\n\nimport { defineFrontendPluginManifest } from \"../manifest\";\nimport { type FrontendBuildOutput } from \"../types\";\nimport { cp, slash } from \"../utils\";\n/**\n * Bundles the frontend plugin\n * @param pluginPackageDir - The directory to bundle the plugin into.\n * @param buildOutput - The build output.\n */\nexport function bundleFrontendPlugin(\n  cwd: string,\n  pluginPackageDir: string,\n  buildOutput: FrontendBuildOutput,\n) {\n  // Create plugin directory\n  const pluginDir = path.join(pluginPackageDir, buildOutput.id);\n  fs.mkdirSync(pluginDir, { recursive: true });\n\n  // Copy JS file\n  const jsDestPath = path.join(pluginDir, path.basename(buildOutput.fileName));\n  fs.copyFileSync(buildOutput.fileName, jsDestPath);\n  const jsRelativePath = slash(path.relative(pluginPackageDir, jsDestPath));\n\n  // Copy CSS file if it exists\n  let cssRelativePath: string | undefined;\n  if (buildOutput.cssFileName) {\n    const cssDestPath = path.join(\n      pluginDir,\n      path.basename(buildOutput.cssFileName),\n    );\n    fs.copyFileSync(buildOutput.cssFileName, cssDestPath);\n    cssRelativePath = slash(path.relative(pluginPackageDir, cssDestPath));\n  }\n\n  // Copy assets if required\n  let assetsRelativePath: string | undefined;\n  if (buildOutput.assets.length > 0) {\n    // Create assets directory\n    const assetsDir = path.join(pluginDir, \"assets\");\n    fs.mkdirSync(assetsDir, { recursive: true });\n\n    // Copy assets\n    for (const asset of buildOutput.assets) {\n      cp(cwd, asset, assetsDir);\n    }\n\n    assetsRelativePath = slash(path.relative(pluginPackageDir, assetsDir));\n  }\n\n  return defineFrontendPluginManifest({\n    id: buildOutput.id,\n    kind: \"frontend\",\n    name: buildOutput.name ?? buildOutput.id,\n    entrypoint: jsRelativePath,\n    style: cssRelativePath,\n    backend: buildOutput.backendId ? { id: buildOutput.backendId } : null,\n    assets: assetsRelativePath,\n  });\n}\n","import path from \"path\";\n\nimport { createJiti } from \"jiti\";\n\nimport { type CaidoConfig, caidoConfigSchema } from \"./types\";\nimport { logInfo } from \"./utils\";\n\nconst DEFAULT_CONFIG_FILE = \"caido.config.ts\";\n\nexport async function loadConfig(\n  cwd: string,\n  configPath?: string,\n): Promise<CaidoConfig> {\n  const configFile = configPath || path.resolve(cwd, DEFAULT_CONFIG_FILE);\n  logInfo(`Loading configuration: ${configFile}`);\n\n  try {\n    // Use jiti for dynamic imports\n    const jiti = createJiti(process.cwd(), { interopDefault: true });\n    const config = await jiti.import(configFile, { default: true });\n    return caidoConfigSchema.parse(config);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to load configuration: ${error.message}`);\n    }\n    throw new Error(\"Unknown error occurred\");\n  }\n}\n\nexport const defineConfig = (config: CaidoConfig) => {\n  return config;\n};\n","import { type UserConfig as ViteConfig } from \"vite\";\nimport { z } from \"zod\";\n\nexport type FrontendBuildOutput = {\n  kind: \"frontend\";\n  id: string;\n  name: string;\n  fileName: string;\n  cssFileName: string | undefined;\n  backendId: string | undefined;\n  assets: string[];\n};\n\nexport type BackendBuildOutput = {\n  kind: \"backend\";\n  id: string;\n  name: string;\n  fileName: string;\n  assets: string[];\n};\n\nexport type BuildOutput = FrontendBuildOutput | BackendBuildOutput;\n\nexport const backendReferenceConfigSchema = z.strictObject({ id: z.string() });\n\nconst viteSchema: z.ZodType<ViteConfig> = z.record(z.string(), z.unknown());\n\nexport const assetsConfigSchema = z.array(z.string()).optional();\n\nexport const frontendPluginConfigSchema = z.strictObject({\n  kind: z.literal(\"frontend\"),\n  id: z.string(),\n  name: z.string().optional(),\n  root: z.string(),\n  assets: assetsConfigSchema,\n  backend: backendReferenceConfigSchema.nullable().optional(),\n  vite: viteSchema.optional(),\n});\n\nexport const backendPluginConfigSchema = z.strictObject({\n  kind: z.literal(\"backend\"),\n  id: z.string(),\n  name: z.string().optional(),\n  root: z.string(),\n  assets: assetsConfigSchema,\n});\n\nexport const workflowPluginConfigSchema = z.strictObject({\n  kind: z.literal(\"workflow\"),\n  id: z.string(),\n  name: z.string(),\n  root: z.string(),\n  definition: z.string(),\n});\n\nexport const linksConfigSchema = z.strictObject({\n  sponsor: z.string().url().optional(),\n});\n\nexport const watchConfigSchema = z.strictObject({\n  port: z.number().optional(),\n});\n\nexport const caidoConfigSchema = z.strictObject({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  version: z.string().regex(/^\\d+\\.\\d+\\.\\d+$/),\n  author: z.object({\n    name: z.string(),\n    email: z.string().email().optional(),\n    url: z.string().url().optional(),\n  }),\n  links: linksConfigSchema.optional(),\n  plugins: z.array(\n    z.discriminatedUnion(\"kind\", [\n      frontendPluginConfigSchema,\n      backendPluginConfigSchema,\n      workflowPluginConfigSchema,\n    ]),\n  ),\n  watch: watchConfigSchema.optional(),\n});\n\n// Type inference\nexport type BackendReferenceConfig = z.infer<\n  typeof backendReferenceConfigSchema\n>;\nexport type FrontendPluginConfig = z.infer<typeof frontendPluginConfigSchema>;\nexport type BackendPluginConfig = z.infer<typeof backendPluginConfigSchema>;\nexport type WorkflowPluginConfig = z.infer<typeof workflowPluginConfigSchema>;\nexport type WatchConfig = z.infer<typeof watchConfigSchema>;\nexport type CaidoConfig = z.infer<typeof caidoConfigSchema>;\n\nexport type ConnectedMessage = {\n  kind: \"connected\";\n  packageId: string;\n  downloadUrl: string;\n};\n\nexport type RebuildMessage = {\n  kind: \"rebuild\";\n  downloadUrl: string;\n};\n\nexport type ErrorMessage = {\n  kind: \"error\";\n  error: string;\n};\n","import { buildBackendPlugin, buildFrontendPlugin } from \"../build\";\nimport { bundlePackage } from \"../bundle\";\nimport { loadConfig } from \"../config\";\nimport type { BuildOutput } from \"../types\";\nimport { logInfo, logSuccess } from \"../utils\";\n\nexport async function build(options: { path?: string; config?: string }) {\n  logInfo(\"Building plugin package\");\n  const { path: cwd = process.cwd(), config: configPath } = options;\n\n  // Load configuration\n  const config = await loadConfig(cwd, configPath);\n\n  // Build plugins\n  const buildOutputs: BuildOutput[] = [];\n  for (const plugin of config.plugins) {\n    switch (plugin.kind) {\n      case \"frontend\":\n        buildOutputs.push(await buildFrontendPlugin(cwd, plugin));\n        break;\n      case \"backend\":\n        buildOutputs.push(await buildBackendPlugin(cwd, plugin));\n        break;\n      case \"workflow\":\n        break;\n    }\n  }\n\n  // Bundle the plugin\n  await bundlePackage({\n    cwd,\n    buildOutputs,\n    config,\n  });\n  logSuccess(\"Plugin package built successfully\");\n}\n","import fs from \"fs/promises\";\nimport { createServer } from \"http\";\nimport path from \"path\";\n\nimport { Glob } from \"glob\";\n\nimport { watch as chokidarWatch } from \"chokidar\";\nimport express, { type Request, type Response } from \"express\";\nimport { type WebSocket, WebSocketServer } from \"ws\";\n\nimport { loadConfig } from \"../config\";\nimport {\n  type ConnectedMessage,\n  type ErrorMessage,\n  type RebuildMessage,\n} from \"../types\";\nimport { logError, logInfo, slash } from \"../utils\";\n\nimport { build } from \"./build\";\n\nexport async function watch(options: { path?: string; config?: string }) {\n  const { path: cwd = process.cwd(), config: configPath } = options;\n\n  const config = await loadConfig(cwd, configPath);\n  const { port = 3000 } = config.watch ?? {};\n\n  const downloadUrl = `http://localhost:${port}/plugin_package.zip`;\n\n  const app = express();\n  const server = createServer(app);\n  const wss = new WebSocketServer({ server });\n\n  // Keep track of connected clients\n  const clients = new Set<WebSocket>();\n\n  wss.on(\"connection\", (ws: WebSocket) => {\n    clients.add(ws);\n    ws.on(\"close\", () => clients.delete(ws));\n\n    const message: ConnectedMessage = {\n      kind: \"connected\",\n      packageId: config.id,\n      downloadUrl,\n    };\n\n    ws.send(JSON.stringify(message));\n  });\n\n  // Function to notify all clients of a rebuild\n  const notifyRebuild = () => {\n    const message: RebuildMessage = {\n      kind: \"rebuild\",\n      downloadUrl,\n    };\n    clients.forEach((client) => client.send(JSON.stringify(message)));\n  };\n\n  // Function to notify all clients of an error\n  const notifyError = (error: string) => {\n    const message: ErrorMessage = {\n      kind: \"error\",\n      error,\n    };\n\n    clients.forEach((client) => client.send(JSON.stringify(message)));\n  };\n\n  // Serve the plugin package\n  app.get(\"/plugin_package.zip\", async (req: Request, res: Response) => {\n    const pluginPath = path.join(cwd, \"dist\", \"plugin_package.zip\");\n    try {\n      await fs.access(pluginPath);\n      res.download(pluginPath);\n    } catch {\n      res.status(404).send(\"Plugin package not found\");\n    }\n  });\n\n  // Initial build\n  try {\n    await build(options);\n    notifyRebuild();\n  } catch (error) {\n    if (error instanceof Error) {\n      logError(error.message);\n      notifyError(error.message);\n    } else {\n      logError(\"Unknown error\");\n      notifyError(\"Unknown error\");\n    }\n  }\n\n  // Watch for changes\n  const watchPatterns = config.plugins.map((plugin) =>\n    path.join(cwd, plugin.root, \"**/*\"),\n  );\n  const watchFiles = await Promise.all(\n    watchPatterns.map(async (pattern) => {\n      const files = [];\n      const glob = new Glob(slash(pattern), {\n        ignore: [\"**/node_modules/**\", \"**/dist/**\"],\n      });\n      for await (const file of glob) {\n        files.push(file);\n      }\n      return files;\n    }),\n  );\n  const filesToWatch = [\n    ...watchFiles.flat(),\n    path.join(cwd, \"package.json\"),\n    path.join(cwd, \"caido.config.ts\"),\n  ];\n  const watcher = chokidarWatch(filesToWatch, {\n    ignoreInitial: true,\n    ignored: (f) => f.includes(\"dist/\") || f.includes(\"node_modules/\"),\n  });\n\n  watcher.on(\"all\", async (event: string, filePath: string) => {\n    logInfo(`File ${filePath} has been ${event}`);\n    try {\n      await build(options);\n      notifyRebuild();\n    } catch (error) {\n      notifyError(error instanceof Error ? error.message : \"Unknown error\");\n    }\n  });\n\n  // Start the server\n  server.listen(port, () => {\n    logInfo(`Development server running at http://localhost:${port}`);\n    logInfo(`WebSocket server running at ws://localhost:${port}`);\n  });\n}\n"],"mappings":"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","names":["chalk","path","path","path","path","build","defineConfig","path","defineConfig","build","fs","path","fs","path","path","fs","fs","path","path","fs","path","fs","path","path","build","fs","path","Glob","path","fs","build","Glob","chalk","path","build"]}