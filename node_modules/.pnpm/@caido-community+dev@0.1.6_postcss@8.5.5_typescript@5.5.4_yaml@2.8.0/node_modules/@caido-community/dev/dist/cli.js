#!/usr/bin/env node

// src/cli.ts
import chalk2 from "chalk";
import { Command } from "commander";

// src/build/frontend.ts
import { existsSync } from "fs";
import path2 from "path";
import { build, defineConfig, mergeConfig } from "vite";

// src/utils/cp.ts
import fs from "fs";
import path from "path";
import { Glob } from "glob";
function cp(cwd, src, dest) {
  const glob = new Glob(src, { cwd });
  for (const file of glob) {
    const fileSrc = path.join(cwd, file);
    let fileDest = dest;
    if (fs.statSync(fileSrc).isFile()) {
      const fileName = path.basename(file);
      fileDest = path.join(dest, fileName);
    }
    fs.cpSync(fileSrc, fileDest, { recursive: true });
  }
}

// src/utils/log.ts
import chalk from "chalk";
function logSuccess(message) {
  console.log(chalk.green("[*]"), message);
}
function logInfo(message) {
  console.log(chalk.blue("[*]"), message);
}
function logError(message) {
  console.error(chalk.red("[!]"), message);
}

// src/utils/slash.ts
function slash(path9) {
  return path9.replace(/\\/g, "/");
}

// src/utils/zip.ts
import { readdir, readFile, stat } from "fs/promises";
import { join } from "path";
async function addDirectoryToZip(zip, dirPath, parentPath = "") {
  const entries = await readdir(dirPath);
  for (const entry of entries) {
    const fullPath = join(dirPath, entry);
    const stats = await stat(fullPath);
    const relativePath = parentPath ? join(parentPath, entry) : entry;
    if (stats.isDirectory()) {
      await addDirectoryToZip(zip, fullPath, relativePath);
    } else {
      const content = await readFile(fullPath);
      zip.file(slash(relativePath), content);
    }
  }
}

// src/build/frontend.ts
function createViteConfig(cwd, plugin) {
  const root = path2.resolve(cwd, plugin.root);
  const baseConfig = defineConfig({
    root,
    build: {
      outDir: "dist",
      emptyOutDir: true,
      lib: {
        entry: "src/index.ts",
        formats: ["es"],
        fileName: () => "index.js",
        cssFileName: "index"
      }
    },
    define: { "process.env.NODE_ENV": '"production"' }
  });
  return mergeConfig(baseConfig, plugin.vite ?? {});
}
async function buildFrontendPlugin(cwd, pluginConfig) {
  const pluginRoot = path2.resolve(cwd, pluginConfig.root);
  logInfo(`Building frontend plugin: ${pluginRoot}`);
  const viteConfig = createViteConfig(cwd, pluginConfig);
  await build(viteConfig);
  const hasCss = existsSync(`${pluginRoot}/dist/index.css`);
  logInfo("Frontend plugin built successfully");
  return {
    kind: "frontend",
    id: pluginConfig.id,
    name: pluginConfig.name ?? "frontend",
    fileName: path2.join(pluginRoot, "dist", "index.js"),
    cssFileName: hasCss ? path2.join(pluginRoot, "dist", "index.css") : void 0,
    backendId: pluginConfig.backend?.id,
    assets: pluginConfig.assets ?? []
  };
}

// src/build/backend.ts
import { builtinModules } from "module";
import path3 from "path";
import { build as build2, defineConfig as defineConfig2 } from "tsup";
function createTsupConfig(cwd, plugin) {
  const root = path3.resolve(cwd, plugin.root);
  return defineConfig2({
    target: "esnext",
    entry: [slash(path3.resolve(root, "src/index.ts"))],
    outDir: slash(path3.resolve(root, "dist")),
    outExtension: (ctx) => {
      return { js: ".js" };
    },
    format: ["esm"],
    config: false,
    clean: true,
    sourcemap: false,
    external: [/caido:.+/, "sqlite", ...builtinModules]
  });
}
async function buildBackendPlugin(cwd, pluginConfig) {
  const pluginRoot = path3.resolve(cwd, pluginConfig.root);
  logInfo(`Building backend plugin: ${pluginRoot}`);
  const tsupConfig = createTsupConfig(cwd, pluginConfig);
  await build2(tsupConfig);
  logInfo("Backend built successfully");
  return {
    kind: "backend",
    id: pluginConfig.id,
    name: pluginConfig.name ?? "backend",
    fileName: path3.join(pluginRoot, "dist", "index.js"),
    assets: pluginConfig.assets ?? []
  };
}

// src/bundle/index.ts
import fs4 from "fs/promises";
import path6 from "path";
import { validateManifest } from "@caido/plugin-manifest";
import JSZip from "jszip";

// src/manifest.ts
function createManifest(options) {
  const { config } = options;
  return {
    id: config.id,
    name: config.name,
    version: config.version,
    description: config.description,
    author: {
      name: config.author.name,
      email: config.author?.email,
      url: config.author?.url
    },
    links: {
      sponsor: config.links?.sponsor
    },
    plugins: []
  };
}
function defineFrontendPluginManifest(pluginManifest) {
  return pluginManifest;
}
function defineBackendPluginManifest(pluginManifest) {
  return pluginManifest;
}

// src/bundle/backend.ts
import fs2 from "fs";
import path4 from "path";
function bundleBackendPlugin(cwd, pluginPackageDir, buildOutput) {
  const pluginDir = path4.join(pluginPackageDir, buildOutput.id);
  fs2.mkdirSync(pluginDir, { recursive: true });
  const jsDestPath = path4.join(pluginDir, path4.basename(buildOutput.fileName));
  fs2.copyFileSync(buildOutput.fileName, jsDestPath);
  const jsRelativePath = slash(path4.relative(pluginPackageDir, jsDestPath));
  let assetsRelativePath;
  if (buildOutput.assets.length > 0) {
    const assetsDir = path4.join(pluginDir, "assets");
    fs2.mkdirSync(assetsDir, { recursive: true });
    for (const asset of buildOutput.assets) {
      cp(cwd, asset, assetsDir);
    }
    assetsRelativePath = slash(path4.relative(pluginPackageDir, assetsDir));
  }
  return defineBackendPluginManifest({
    id: buildOutput.id,
    kind: "backend",
    name: buildOutput.name ?? buildOutput.id,
    entrypoint: jsRelativePath,
    runtime: "javascript",
    assets: assetsRelativePath
  });
}

// src/bundle/frontend.ts
import fs3 from "fs";
import path5 from "path";
function bundleFrontendPlugin(cwd, pluginPackageDir, buildOutput) {
  const pluginDir = path5.join(pluginPackageDir, buildOutput.id);
  fs3.mkdirSync(pluginDir, { recursive: true });
  const jsDestPath = path5.join(pluginDir, path5.basename(buildOutput.fileName));
  fs3.copyFileSync(buildOutput.fileName, jsDestPath);
  const jsRelativePath = slash(path5.relative(pluginPackageDir, jsDestPath));
  let cssRelativePath;
  if (buildOutput.cssFileName) {
    const cssDestPath = path5.join(
      pluginDir,
      path5.basename(buildOutput.cssFileName)
    );
    fs3.copyFileSync(buildOutput.cssFileName, cssDestPath);
    cssRelativePath = slash(path5.relative(pluginPackageDir, cssDestPath));
  }
  let assetsRelativePath;
  if (buildOutput.assets.length > 0) {
    const assetsDir = path5.join(pluginDir, "assets");
    fs3.mkdirSync(assetsDir, { recursive: true });
    for (const asset of buildOutput.assets) {
      cp(cwd, asset, assetsDir);
    }
    assetsRelativePath = slash(path5.relative(pluginPackageDir, assetsDir));
  }
  return defineFrontendPluginManifest({
    id: buildOutput.id,
    kind: "frontend",
    name: buildOutput.name ?? buildOutput.id,
    entrypoint: jsRelativePath,
    style: cssRelativePath,
    backend: buildOutput.backendId ? { id: buildOutput.backendId } : null,
    assets: assetsRelativePath
  });
}

// src/bundle/index.ts
async function createDistDirectories(cwd) {
  const distDir = path6.resolve(cwd, "dist");
  await fs4.rm(distDir, {
    recursive: true,
    force: true
  });
  const pluginPackageDir = path6.join(distDir, "plugin_package");
  await fs4.mkdir(pluginPackageDir, { recursive: true });
  return {
    distDir,
    pluginPackageDir
  };
}
async function bundlePackage(options) {
  logInfo("Bundling plugin package");
  const { cwd, buildOutputs, config } = options;
  const { distDir, pluginPackageDir } = await createDistDirectories(cwd);
  const manifest = createManifest({ config });
  for (const buildOutput of buildOutputs) {
    switch (buildOutput.kind) {
      case "frontend":
        manifest.plugins.push(
          bundleFrontendPlugin(cwd, pluginPackageDir, buildOutput)
        );
        break;
      case "backend":
        manifest.plugins.push(
          bundleBackendPlugin(cwd, pluginPackageDir, buildOutput)
        );
        break;
    }
  }
  if (!validateManifest(manifest)) {
    throw new Error(
      "Manifest is not valid:" + JSON.stringify(manifest, null, 2)
    );
  }
  const manifestPath = path6.join(pluginPackageDir, "manifest.json");
  const manifestContent = JSON.stringify(manifest, null, 2);
  await fs4.writeFile(manifestPath, manifestContent);
  const zip = new JSZip();
  await addDirectoryToZip(zip, pluginPackageDir);
  const zipPath = path6.join(distDir, "plugin_package.zip");
  const zipFile = await fs4.open(zipPath, "w");
  await new Promise((resolve, reject) => {
    zip.generateNodeStream({
      type: "nodebuffer",
      streamFiles: true
    }).pipe(zipFile.createWriteStream()).on("finish", () => {
      logSuccess("Plugin package zip file created successfully");
      resolve();
    }).on("error", reject);
  });
}

// src/config.ts
import path7 from "path";
import { createJiti } from "jiti";

// src/types.ts
import { z } from "zod";
var backendReferenceConfigSchema = z.strictObject({ id: z.string() });
var viteSchema = z.record(z.string(), z.unknown());
var assetsConfigSchema = z.array(z.string()).optional();
var frontendPluginConfigSchema = z.strictObject({
  kind: z.literal("frontend"),
  id: z.string(),
  name: z.string().optional(),
  root: z.string(),
  assets: assetsConfigSchema,
  backend: backendReferenceConfigSchema.nullable().optional(),
  vite: viteSchema.optional()
});
var backendPluginConfigSchema = z.strictObject({
  kind: z.literal("backend"),
  id: z.string(),
  name: z.string().optional(),
  root: z.string(),
  assets: assetsConfigSchema
});
var workflowPluginConfigSchema = z.strictObject({
  kind: z.literal("workflow"),
  id: z.string(),
  name: z.string(),
  root: z.string(),
  definition: z.string()
});
var linksConfigSchema = z.strictObject({
  sponsor: z.string().url().optional()
});
var watchConfigSchema = z.strictObject({
  port: z.number().optional()
});
var caidoConfigSchema = z.strictObject({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  version: z.string().regex(/^\d+\.\d+\.\d+$/),
  author: z.object({
    name: z.string(),
    email: z.string().email().optional(),
    url: z.string().url().optional()
  }),
  links: linksConfigSchema.optional(),
  plugins: z.array(
    z.discriminatedUnion("kind", [
      frontendPluginConfigSchema,
      backendPluginConfigSchema,
      workflowPluginConfigSchema
    ])
  ),
  watch: watchConfigSchema.optional()
});

// src/config.ts
var DEFAULT_CONFIG_FILE = "caido.config.ts";
async function loadConfig(cwd, configPath) {
  const configFile = configPath || path7.resolve(cwd, DEFAULT_CONFIG_FILE);
  logInfo(`Loading configuration: ${configFile}`);
  try {
    const jiti = createJiti(process.cwd(), { interopDefault: true });
    const config = await jiti.import(configFile, { default: true });
    return caidoConfigSchema.parse(config);
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to load configuration: ${error.message}`);
    }
    throw new Error("Unknown error occurred");
  }
}

// src/commands/build.ts
async function build3(options) {
  logInfo("Building plugin package");
  const { path: cwd = process.cwd(), config: configPath } = options;
  const config = await loadConfig(cwd, configPath);
  const buildOutputs = [];
  for (const plugin of config.plugins) {
    switch (plugin.kind) {
      case "frontend":
        buildOutputs.push(await buildFrontendPlugin(cwd, plugin));
        break;
      case "backend":
        buildOutputs.push(await buildBackendPlugin(cwd, plugin));
        break;
      case "workflow":
        break;
    }
  }
  await bundlePackage({
    cwd,
    buildOutputs,
    config
  });
  logSuccess("Plugin package built successfully");
}

// src/commands/watch.ts
import fs5 from "fs/promises";
import { createServer } from "http";
import path8 from "path";
import { Glob as Glob2 } from "glob";
import { watch as chokidarWatch } from "chokidar";
import express from "express";
import { WebSocketServer } from "ws";
async function watch(options) {
  const { path: cwd = process.cwd(), config: configPath } = options;
  const config = await loadConfig(cwd, configPath);
  const { port = 3e3 } = config.watch ?? {};
  const downloadUrl = `http://localhost:${port}/plugin_package.zip`;
  const app = express();
  const server = createServer(app);
  const wss = new WebSocketServer({ server });
  const clients = /* @__PURE__ */ new Set();
  wss.on("connection", (ws) => {
    clients.add(ws);
    ws.on("close", () => clients.delete(ws));
    const message = {
      kind: "connected",
      packageId: config.id,
      downloadUrl
    };
    ws.send(JSON.stringify(message));
  });
  const notifyRebuild = () => {
    const message = {
      kind: "rebuild",
      downloadUrl
    };
    clients.forEach((client) => client.send(JSON.stringify(message)));
  };
  const notifyError = (error) => {
    const message = {
      kind: "error",
      error
    };
    clients.forEach((client) => client.send(JSON.stringify(message)));
  };
  app.get("/plugin_package.zip", async (req, res) => {
    const pluginPath = path8.join(cwd, "dist", "plugin_package.zip");
    try {
      await fs5.access(pluginPath);
      res.download(pluginPath);
    } catch {
      res.status(404).send("Plugin package not found");
    }
  });
  try {
    await build3(options);
    notifyRebuild();
  } catch (error) {
    if (error instanceof Error) {
      logError(error.message);
      notifyError(error.message);
    } else {
      logError("Unknown error");
      notifyError("Unknown error");
    }
  }
  const watchPatterns = config.plugins.map(
    (plugin) => path8.join(cwd, plugin.root, "**/*")
  );
  const watchFiles = await Promise.all(
    watchPatterns.map(async (pattern) => {
      const files = [];
      const glob = new Glob2(slash(pattern), {
        ignore: ["**/node_modules/**", "**/dist/**"]
      });
      for await (const file of glob) {
        files.push(file);
      }
      return files;
    })
  );
  const filesToWatch = [
    ...watchFiles.flat(),
    path8.join(cwd, "package.json"),
    path8.join(cwd, "caido.config.ts")
  ];
  const watcher = chokidarWatch(filesToWatch, {
    ignoreInitial: true,
    ignored: (f) => f.includes("dist/") || f.includes("node_modules/")
  });
  watcher.on("all", async (event, filePath) => {
    logInfo(`File ${filePath} has been ${event}`);
    try {
      await build3(options);
      notifyRebuild();
    } catch (error) {
      notifyError(error instanceof Error ? error.message : "Unknown error");
    }
  });
  server.listen(port, () => {
    logInfo(`Development server running at http://localhost:${port}`);
    logInfo(`WebSocket server running at ws://localhost:${port}`);
  });
}

// src/cli.ts
var program = new Command();
function runner(fn) {
  return async (...args) => {
    try {
      await fn(...args);
    } catch (error) {
      const buildError = error instanceof Error ? error : new Error("Unknown error occurred");
      console.error(chalk2.red(`
${buildError.message}`));
      console.error(chalk2.red(`${buildError.stack}`));
      process.exit(1);
    }
  };
}
program.name("caido-dev").description("Development tools for building Caido plugins").version("1.0.0");
program.command("build [path]").description("Build the Caido plugin").option("-c, --config <path>", "Path to caido.config.ts file").action(
  runner(
    (path9, args) => build3({
      path: path9,
      ...args
    })
  )
);
program.command("watch [path]").description("Start development server and watch for changes").option("-c, --config <path>", "Path to caido.config.ts file").action(
  runner(
    (path9, args) => watch({
      path: path9,
      ...args
    })
  )
);
program.command("dev").description("Start development server").option("-c, --config <path>", "Path to caido.config.ts file").action(() => {
});
try {
  program.parse();
} catch (error) {
  const buildError = error instanceof Error ? error : new Error("Unknown error occurred");
  console.error(chalk2.red(`
${buildError.message}`));
  process.exit(1);
}
//# sourceMappingURL=cli.js.map